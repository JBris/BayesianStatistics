# observed data
gss = list(
  n = 550, 
  y = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
        1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 12, 
        12, 12, 12, 12, 13, 13, 13, 15, 15, 15, 16, 16, 16, 20, 20, 20, 20, 20, 20, 20, 24, 25, 30, 30, 30, 50, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 17, 18, 20, 20, 20, 20, 20, 20, 22, 23, 25, 25, 25, 27, 30), 
  gender = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
)

# zero-inflated poisson glm model
zip_glm_code = "
data {
  int<lower=1> n;  // number of observations
  int y[n];  // count of sexual intercourse in previous month
  int<lower=0, upper=1> gender[n];  // male = 0, female = 1
}
parameters {
  vector[2] p0; //vector of probabilities
  vector[2] beta; //related to mean of poisson
}
transformed parameters {
  vector[n] log_lambda;
  for(i in 1:n) {
    // log mean of Poisson
    log_lambda[i] = beta[1] + beta[2] * gender[i] ;
  }
}
model {
  // prior distributions
  // different parameter for each gender
  for (j in 1:2) {
    beta[j] ~ normal(0, sqrt(1000));
    p0[j] ~ beta(1, 1);
  }

  for (i in 1:n) {
      if (y[i] == 0)
        target += log_sum_exp(bernoulli_lpmf(1 | p0[gender[i] + 1]),
                              bernoulli_lpmf(0 | p0[gender[i] + 1])
                                + poisson_log_lpmf(y[i] | log_lambda[i]));
      else
        target += bernoulli_lpmf(0 | p0[gender[i] + 1])
                    + poisson_log_lpmf(y[i] | log_lambda[i]);
  }
}
generated quantities {
  vector[n] yrep;
  vector[n] log_lik;
  vector[2] lambda;
  vector[2] mu;
  vector[2] v;
  for(i in 1:n) {
    if(bernoulli_rng(p0[gender[i] + 1])) {
      yrep[i] = 0;
    } else {
      yrep[i] = poisson_log_rng(log_lambda[i]);
    }
    if(y[i] == 0) {
      log_lik[i] = log_sum_exp(bernoulli_lpmf(1 | p0[gender[i] + 1]),
                               bernoulli_lpmf(0 | p0[gender[i] + 1])
                               + poisson_log_lpmf(y[i] | log_lambda[i]));
    } else {
      log_lik[i] = bernoulli_lpmf(0 | p0[gender[i] + 1]) + poisson_log_lpmf(y[i] | log_lambda[i]);
    }
  }
  for(j in 1:2) {
    lambda[j] = exp(beta[1] + beta[2] * (j == 2));
    mu[j] = (1 - p0[j]) * lambda[j];
    v[j] = (1 - p0[j]) * (lambda[j] + p0[j] * lambda[j] * lambda[j]);
  }
}
"

init_fun_zip_glm = function() { 
  list(beta = rnorm(2), p0 = runif(2)) 
} 

library(rstan)
# zip_glm = stan(model_code = zip_glm_code, data = gss,
#                 iter = 5e3, seed = 93,
#                 init = init_fun_zip_glm)
# 
# params_zip_glm = as.array(zip_glm,
#                           pars = c("p0", "beta", "mu", "v"))
# save(params_zip_glm, file = "example_8_3_zip_glm_params.rda")
load(file = "example_8_3_zip_glm_params.rda")

## summary information
# summary_zip_glm = summary(zip_glm,
#                           pars = c("p0", "beta", "mu", "v"))
# save(summary_zip_glm, file = "example_8_3_zip_glm_summary.rda")
load(file = "example_8_3_zip_glm_summary.rda")
summary_zip_glm$summary

# trace plots
library(bayesplot)
mcmc_trace(params_zip_glm, regex_pars = c("beta", "p0"))
mcmc_trace(params_zip_glm, regex_pars = c("mu", "v"))

library(loo)
# ll_zip_glm = extract_log_lik(zip_glm, merge_chains = FALSE)
# # compute waic
# waic_zip_glm = waic(ll_zip_glm)
# # compute effective sample size of liklihood
# r_eff_zip_glm = relative_eff(exp(ll_zip_glm))
# # compute looic (using effective sample size)
# looic_zip_glm = loo(ll_zip_glm, r_eff = r_eff_zip_glm)
# save(waic_zip_glm, looic_zip_glm,
#      file = "example_8_3_zip_glm_ic.rda")
load(file = "example_8_3_zip_glm_ic.rda")
waic_zip_glm
looic_zip_glm

# # extract small subset of yrep
# samples_zip_glm = extract(zip_glm)
# s = sample(seq_len(nrow(samples_zip_glm$log_lik)), 1000)
# yrep_zip_glm = samples_zip_glm$yrep[s, ]
# save(yrep_zip_glm, file = "example_8_3_zip_glm_yrep.rda")
load(file = "example_8_3_zip_glm_yrep.rda")

ppc_hist(gss$y, yrep_zip_glm[1:8, ])
ppc_ecdf_overlay(gss$y, yrep_zip_glm)
ppc_intervals(gss$y, yrep_zip_glm)

